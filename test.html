<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RPG Hardcore Shield - Physics Logic</title>
  <style>
      body {
          margin: 0;
          padding: 0;
          background-color: #050505;
          overflow: hidden;
          font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
          user-select: none;
      }

      canvas {
          display: block;
      }

      /* HUD 界面 */
      #controls {
          position: absolute;
          bottom: 60px;
          left: 50%;
          transform: translateX(-50%);
          display: flex;
          gap: 10px;
          z-index: 10;
          align-items: center;
      }

      /* 分组 */
      .group {
          display: flex;
          gap: 5px;
          padding: 5px;
          background: rgba(20, 25, 30, 0.6);
          border-radius: 6px;
          border: 1px solid #333;
      }

      button {
          position: relative;
          background: rgba(16, 20, 24, 0.95);
          color: #8faab5;
          border: 1px solid #2c3e50;
          padding: 10px 18px;
          font-size: 13px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 1px;
          cursor: pointer;
          transition: all 0.15s;
          box-shadow: 0 2px 5px rgba(0,0,0,0.5);
          min-width: 80px;
      }

      button:hover {
          transform: translateY(-2px);
          color: #fff;
          background: rgba(30, 40, 50, 0.95);
      }

      button:active {
          transform: translateY(1px);
      }

      /* 颜色区分 */
      .btn-add { border-bottom: 2px solid #00eaff; color: #00eaff; }
      .btn-add:hover { box-shadow: 0 0 10px rgba(0, 234, 255, 0.2); }

      .btn-dmg { border-bottom: 2px solid #ffaa00; color: #ffaa00; }
      .btn-dmg:hover { box-shadow: 0 0 10px rgba(255, 170, 0, 0.2); }

      .btn-break { border-bottom: 2px solid #ff3333; color: #ff3333; }
      .btn-break:hover { box-shadow: 0 0 10px rgba(255, 51, 51, 0.3); }

      #status {
          position: absolute;
          top: 40px;
          width: 100%;
          text-align: center;
          color: rgba(0, 234, 255, 0.4);
          font-size: 11px;
          letter-spacing: 3px;
          font-family: monospace;
          text-shadow: 0 0 5px rgba(0, 234, 255, 0.3);
          pointer-events: none;
      }
  </style>
</head>
<body>

<div id="status">HEX MATRIX SYSTEM /// PHYSICS READY</div>

<div id="controls">
  <div class="group">
    <button class="btn-add" onclick="shieldSystem.addShield(30)">+30% 盾</button>
    <button class="btn-add" onclick="shieldSystem.addShield(50)">+50% 盾</button>
    <button class="btn-add" onclick="shieldSystem.addShield(100)">满盾</button>
  </div>
  <div class="group">
    <button class="btn-dmg" onclick="shieldSystem.takeDamage(20)">打击</button>
    <button class="btn-break" onclick="shieldSystem.shatter()">直接击碎</button>
  </div>
</div>

<canvas id="canvas"></canvas>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let width, height, centerX, centerY;

  // --- 核心配置 ---
  const CONFIG = {
    barWidth: 440,
    barHeight: 36,

    // 蜂巢参数
    hexRadius: 10,
    hexGap: 2,

    // 视觉风格
    colorShield: '#00eaff',
    colorHit: '#ffffff',
    colorBg: '#08080a',
    colorHpStart: '#8b0000',
    colorHpEnd: '#e60000',

    // 刷新动画 (Refresh)
    sweepSpeed: 6.0,
    sweepInterval: 180,

    // 合体动画
    assemblySpeed: 0.05,

    // 受击物理 (Impact)
    impactForce: 10,
    friction: 0.9,

    shakeIntensity: 8
  };

  const random = (min, max) => Math.random() * (max - min) + min;

  class HexCell {
    constructor(row, col) {
      this.row = row;
      this.col = col;

      // 计算六边形标准位置
      const r = CONFIG.hexRadius;
      const h = r * Math.sin(Math.PI/3);
      const xOffset = (col * (2 * h + CONFIG.hexGap)) + (row % 2) * h;
      const yOffset = row * (1.5 * r + CONFIG.hexGap * 0.8);

      // 相对于血条中心的坐标
      this.targetXRel = xOffset - CONFIG.barWidth / 2 + 10;
      this.targetYRel = yOffset - CONFIG.barHeight / 2 + 5;

      // 物理位置
      this.x = 0; this.y = 0;
      this.vx = 0; this.vy = 0;

      // 偏移量 (受击变形用)
      this.shockX = 0;
      this.shockY = 0;

      // 状态属性
      this.life = 0;
      this.highlight = 0;
      this.isActive = false; // 关键：标记该单元是否处于激活显示区

      // 形态控制: 0 = 粒子点, 1 = 完整六边形
      this.morphProgress = 0;
      this.breathOffset = Math.random() * 100;

      this.reset(true);
    }

    reset(hidden = false) {
      if (hidden) {
        this.life = 0;
        this.isActive = false;
        return;
      }
      const angle = random(0, Math.PI * 2);
      const dist = random(500, 900);
      this.x = centerX + Math.cos(angle) * dist;
      this.y = centerY + Math.sin(angle) * dist;

      this.vx = 0; this.vy = 0;
      this.shockX = 0; this.shockY = 0;
      this.life = 1;
      this.highlight = 0;
      this.morphProgress = 0;
      this.isActive = true;
    }

    // 更新逻辑
    // shieldPixelWidth: 当前护盾的像素宽度 (用于判断是否激活)
    update(state, originX, originY, sweepPos, shieldPixelWidth) {
      const targetX = originX + this.targetXRel;
      const targetY = originY + this.targetYRel;

      // 这里的关键逻辑：判断自己是否在护盾范围内
      // barLeft是原点，所以要判断 targetXRel 是否小于 shieldPixelWidth - (barWidth/2)
      // 简化点：targetXRel 是相对于中心的。
      // 左边界相对于中心是 -barWidth/2
      // 当前护盾右边界相对于中心是 -barWidth/2 + shieldPixelWidth

      const relativeRightBound = -CONFIG.barWidth / 2 + shieldPixelWidth;
      const isInRange = this.targetXRel < relativeRightBound;

      if (state === 'ASSEMBLING') {
        // 只有在范围内的才飞过来，范围外的保持沉睡
        if (isInRange) {
          this.isActive = true;
          const dx = targetX - this.x;
          const dy = targetY - this.y;
          const dist = Math.sqrt(dx*dx + dy*dy);

          const speed = CONFIG.assemblySpeed + (dist > 100 ? 0.02 : 0.05);
          this.x += dx * speed;
          this.y += dy * speed;
          this.life = Math.min(1, this.life + 0.05);

          if (dist < 20) this.morphProgress += 0.1;
          else this.morphProgress = 0;
          if (this.morphProgress > 1) this.morphProgress = 1;
        } else {
          this.isActive = false;
          this.life = 0;
        }

      } else if (state === 'IDLE') {
        // 实时更新激活状态
        // 如果护盾减少，右边的单元应该立即消失（或淡出）
        // 这样破碎时它们就不存在了
        if (isInRange) {
          this.isActive = true;
          this.life = Math.min(1, this.life + 0.1);
          this.morphProgress = 1;
        } else {
          this.isActive = false;
          this.life = Math.max(0, this.life - 0.2); // 快速消失
        }

        if (this.isActive) {
          const desiredX = targetX + this.shockX;
          const desiredY = targetY + this.shockY;

          this.shockX *= CONFIG.friction;
          this.shockY *= CONFIG.friction;
          if (Math.abs(this.shockX) < 0.1) this.shockX = 0;
          if (Math.abs(this.shockY) < 0.1) this.shockY = 0;

          this.x = desiredX;
          this.y = desiredY;

          const distToSweep = Math.abs(this.targetXRel - sweepPos);
          if (distToSweep < 40) {
            this.highlight = Math.max(this.highlight, (40 - distToSweep) / 40);
          }
          this.highlight *= 0.92;

          // 呼吸
          const breath = Math.sin(Date.now() * 0.002 + this.breathOffset);
          if (breath > 0.95) this.highlight += 0.05;
        }

      } else if (state === 'SHATTERING') {
        // --- 崩解逻辑 ---
        // 关键：只有 isActive (破碎前一刻存在的) 的单元才会产生碎片
        // 那些因为护盾值低而原本就不显示的，不应该产生碎片

        if (this.isActive) {
          // 形态退化
          this.morphProgress -= 0.08; // 稍微快一点
          if (this.morphProgress < 0) this.morphProgress = 0;

          // 物理飞散
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.4; // 重力

          // 生命消逝
          const fadeSpeed = this.morphProgress < 0.1 ? 0.05 : 0.02;
          this.life -= fadeSpeed;
        } else {
          this.life = 0;
        }
      }
    }

    draw(ctx, isHit) {
      if (this.life <= 0) return;

      const r = CONFIG.hexRadius - 1;

      ctx.save();
      ctx.translate(this.x, this.y);

      if (this.morphProgress < 0.8) {
        // === 粒子/残骸形态 (不花哨) ===
        // 简单的方块碎片，颜色灰暗一点
        const size = (1 + this.morphProgress * 3);

        ctx.fillStyle = isHit ? CONFIG.colorHit : CONFIG.colorShield;
        ctx.globalAlpha = isHit ? 1.0 : this.life * 0.8;

        ctx.beginPath();
        ctx.fillRect(-size/2, -size/2, size, size);
        ctx.fill();

      } else {
        // === 完整蜂巢形态 ===
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = Math.PI / 3 * i;
          const px = r * Math.cos(angle);
          const py = r * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();

        const breath = Math.sin(Date.now() * 0.002 + this.breathOffset);
        let baseAlpha = 0.15 + this.highlight * 0.6;
        if (!isHit && breath > 0.8) baseAlpha += 0.1;

        const alpha = isHit ? 0.9 : baseAlpha * this.life;

        ctx.fillStyle = isHit ? CONFIG.colorHit : CONFIG.colorShield;
        ctx.globalAlpha = alpha;
        ctx.fill();

        ctx.strokeStyle = isHit ? CONFIG.colorHit : CONFIG.colorShield;
        ctx.lineWidth = 1;
        ctx.globalAlpha = isHit ? 1.0 : 0.4 * this.life;
        ctx.stroke();

        if ((this.row + this.col) % 3 === 0 && !isHit) {
          ctx.fillStyle = CONFIG.colorShield;
          ctx.globalAlpha = 0.8 * this.life;
          ctx.fillRect(-1, -1, 2, 2);
        }
      }

      ctx.restore();
    }

    applyImpact(impactX, impactY, force) {
      if (!this.isActive) return;

      const dx = this.x - impactX;
      const dy = this.y - impactY;
      const dist = Math.sqrt(dx*dx + dy*dy) + 0.01;

      if (dist < 150) {
        const power = (150 - dist) / 150;
        const move = power * force;

        const nx = dx / dist;
        const ny = dy / dist;

        this.shockX += nx * move;
        this.shockY += ny * move;
      }
    }

    explode() {
      if (!this.isActive) return;

      const angle = random(0, Math.PI * 2);
      // 降低速度，让碎片更集中，不再满屏乱飞
      const speed = random(5, 12);
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;

      this.morphProgress = random(0.5, 0.9);
    }
  }

  class ShieldSystem {
    constructor() {
      this.cells = [];
      this.state = 'EMPTY';

      this.maxHp = 100;
      this.hp = 80;
      this.maxShield = 100;
      this.shield = 0;

      // 记录破碎那一刻的护盾宽度，确保碎片只在那里产生
      this.breakShieldWidth = 0;

      this.sweepTimer = 0;
      this.shakeTimer = 0;
      this.shakePower = 0;
      this.impactRings = [];

      this.initGrid();
    }

    initGrid() {
      this.cells = [];
      const r = CONFIG.hexRadius;
      const h = r * Math.sin(Math.PI/3);

      const cols = Math.ceil(CONFIG.barWidth / (2 * h)) + 2;
      const rows = Math.ceil(CONFIG.barHeight / (1.5 * r)) + 2;

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          this.cells.push(new HexCell(i, j));
        }
      }
    }

    // 新增：根据数值添加护盾
    addShield(amount) {
      const isNewAssembly = this.state === 'EMPTY' || this.state === 'SHATTERING';

      // 增加护盾值 (不超过上限)
      if (this.state === 'SHATTERING') {
        this.shield = amount; // 破碎时重置
      } else {
        this.shield = Math.min(this.maxShield, this.shield + amount);
      }

      if (isNewAssembly) {
        this.cells.forEach(p => p.reset());
        this.state = 'ASSEMBLING';
        this.sweepTimer = -200;
        setTimeout(() => {
          if (this.state === 'ASSEMBLING') this.state = 'IDLE';
        }, 1200);
      } else {
        // 如果已经在IDLE，只是数值增加了，不需要重置所有粒子
        // 只是那些新进入范围的粒子会自动被 HexCell.update 激活并飞过来
      }
    }

    // 兼容旧调用
    assemble() {
      this.addShield(100);
    }

    takeDamage(amount) {
      if (this.state === 'EMPTY' || this.state === 'SHATTERING') {
        this.hp = Math.max(0, this.hp - amount);
        return;
      }

      if (this.shield > 0) {
        this.shield = Math.max(0, this.shield - amount);

        const isCrit = amount > 30;
        const force = isCrit ? 15 : 6;

        // 只能在当前护盾范围内随机受击
        const shieldPixelW = (this.shield/this.maxShield * CONFIG.barWidth);
        // 确保受击点不超出当前护盾长度
        const hitX = centerX - CONFIG.barWidth/2 + Math.random() * shieldPixelW;
        const hitY = centerY + (Math.random() - 0.5) * CONFIG.barHeight;

        this.shakeTimer = isCrit ? 8 : 4;
        this.shakePower = isCrit ? CONFIG.shakeIntensity : CONFIG.shakeIntensity * 0.5;

        this.cells.forEach(c => c.applyImpact(hitX, hitY, force));

        // 冲击波也变小一点
        this.impactRings.push({
          x: hitX,
          y: hitY,
          r: 5,
          maxR: isCrit ? 80 : 40,
          alpha: 0.8,
          width: isCrit ? 3 : 1
        });

        if (this.shield <= 0) this.shatter();
      } else {
        this.hp = Math.max(0, this.hp - amount);
      }
    }

    shatter() {
      if (this.state === 'SHATTERING' || this.state === 'EMPTY') return;

      this.state = 'SHATTERING';

      // 记录这一刻，虽然shield其实已经是0了，但为了视觉效果，
      // 我们在 update 里其实是看 isActive 属性，它在上一帧已经决定了谁存在

      this.shield = 0;
      this.cells.forEach(c => c.explode());

      // 降低震动幅度 (用户觉得太花哨)
      this.shakeTimer = 15;
      this.shakePower = 15; // 从35降到15

      // 移除全屏白闪，改为稍微柔和的冲击
      this.impactRings.push({
        x: centerX, // 中心点
        y: centerY,
        r: 20,
        maxR: width * 0.4, // 不再扩散全屏
        alpha: 0.5, // 降低不透明度
        width: 5
      });
    }

    draw(ctx) {
      let sx = 0, sy = 0;
      if (this.shakeTimer > 0) {
        sx = (Math.random() - 0.5) * this.shakePower;
        sy = (Math.random() - 0.5) * this.shakePower;
        this.shakeTimer--;
        this.shakePower *= 0.85;
      }

      ctx.save();
      ctx.translate(sx, sy);

      const bx = centerX - CONFIG.barWidth / 2;
      const by = centerY - CONFIG.barHeight / 2;

      // 1. 血条
      ctx.fillStyle = CONFIG.colorBg;
      ctx.fillRect(bx, by, CONFIG.barWidth, CONFIG.barHeight);

      const hpW = (this.hp / this.maxHp) * CONFIG.barWidth;
      if (hpW > 0) {
        const grad = ctx.createLinearGradient(bx, 0, bx + hpW, 0);
        grad.addColorStop(0, CONFIG.colorHpStart);
        grad.addColorStop(1, CONFIG.colorHpEnd);
        ctx.fillStyle = grad;
        ctx.fillRect(bx + 2, by + 2, hpW - 4, CONFIG.barHeight - 4);
      }

      ctx.strokeStyle = '#334455';
      ctx.lineWidth = 2;
      ctx.strokeRect(bx, by, CONFIG.barWidth, CONFIG.barHeight);

      // 2. 护盾
      if (this.state !== 'EMPTY') {
        // 当前护盾宽 (像素)
        // 如果正在破碎，我们不希望它瞬间变成0宽，而是保持之前的状态让粒子飞
        // 但这里我们用 isActive 控制了粒子，所以无所谓
        let shieldW = (this.shield / this.maxShield) * CONFIG.barWidth;

        const isHit = this.shakeTimer > 5;

        this.sweepTimer += CONFIG.sweepSpeed;
        const cycle = CONFIG.barWidth + CONFIG.sweepInterval;
        let sweepPos = (this.sweepTimer % cycle) - CONFIG.barWidth/2;

        ctx.save();

        // 仅在非破碎状态下绘制底色
        if (this.state !== 'SHATTERING') {
          // 裁剪：只显示当前长度的护盾
          ctx.beginPath();
          ctx.rect(bx, by, shieldW, CONFIG.barHeight);
          ctx.clip();

          if (this.shield > 0 && !isHit) {
            ctx.fillStyle = 'rgba(0, 234, 255, 0.05)';
            ctx.fillRect(bx, by, shieldW, CONFIG.barHeight);
          }
        }

        ctx.globalCompositeOperation = 'lighter';

        let activeCount = 0;
        this.cells.forEach(c => {
          // 传入当前护盾像素宽，让 Cell 决定自己显不显示
          c.update(this.state, centerX, centerY, sweepPos, shieldW);
          c.draw(ctx, isHit);
          if (c.life > 0) activeCount++;
        });

        // 扫描线
        if (this.state === 'IDLE') {
          const absSweepX = centerX + sweepPos;
          if (absSweepX > bx && absSweepX < bx + shieldW) {
            const grad = ctx.createLinearGradient(absSweepX, by, absSweepX + 60, by);
            grad.addColorStop(0, 'rgba(0, 255, 255, 0)');
            grad.addColorStop(0.1, 'rgba(0, 255, 255, 0.2)');
            grad.addColorStop(1, 'rgba(0, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(absSweepX, by, 60, CONFIG.barHeight);
          }
        }

        ctx.restore();

        // 冲击波纹 (不在Clip内)
        ctx.globalCompositeOperation = 'source-over';
        for (let i = this.impactRings.length - 1; i >= 0; i--) {
          const ring = this.impactRings[i];
          ctx.beginPath();
          ctx.arc(ring.x, ring.y, ring.r, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255, 255, 255, ${ring.alpha})`;
          ctx.lineWidth = ring.width;
          ctx.stroke();
          ring.r += (ring.maxR - ring.r) * 0.15;
          ring.alpha -= 0.08;
          if (ring.alpha <= 0) this.impactRings.splice(i, 1);
        }

        if (this.state === 'SHATTERING' && activeCount === 0) {
          this.state = 'EMPTY';
        }
      }

      ctx.fillStyle = '#8faab5';
      ctx.font = 'bold 12px monospace';
      ctx.textAlign = 'center';
      const sTxt = this.shield > 0 ? ` [MATRIX: ${Math.ceil(this.shield)}%]` : ' [OFFLINE]';
      ctx.fillText(`HP: ${Math.ceil(this.hp)}${sTxt}`, centerX, centerY + 50);

      ctx.restore();
    }
  }

  const shieldSystem = new ShieldSystem();

  function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    centerX = width / 2;
    centerY = height / 2;
    shieldSystem.initGrid();
  }
  window.addEventListener('resize', resize);
  resize();

  function animate() {
    ctx.clearRect(0, 0, width, height);
    shieldSystem.draw(ctx);
    requestAnimationFrame(animate);
  }
  animate();

  // 不自动演示，等待用户操作
  // setTimeout(() => shieldSystem.addShield(100), 500);

</script>
</body>
</html>
